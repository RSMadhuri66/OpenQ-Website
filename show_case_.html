<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Autonomous Server and Data Processing Simulation</title>
<style>
    body, html {
        height: 100%;
        margin: 0;
        background-color: black;
        overflow: hidden;
        font-family: 'Courier New', monospace;
        color: lime;
    }
    #matrix {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        padding: 20px;
        justify-content: center;
    }
    .window {
        min-height: 220px;
        padding: 20px;
        background-color: rgba(0, 0, 0, 0.8);
        border: 1px solid lime;
        box-shadow: 0 0 10px lime;
        overflow: auto;
        font-size: 12px;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        opacity: 0; /* Start with windows invisible */
    }
    .window.visible {
        animation: fadeIn 1s forwards; /* Only animate to visible when added */
    }
    .window:hover {
        transform: scale(1.05);
        box-shadow: 0 0 15px lime;
    }
    h4 {
        margin: 0 0 10px 0;
        font-size: 18px;
        text-shadow: 0 0 8px lime;
    }
    .ip-address {
        font-size: 12px;
        opacity: 0.7;
    }
    @keyframes fadeIn {
        to { opacity: 1; }
    }
    @keyframes matrixBackground {
        to { background-position: 0 -10000px; }
    }
    body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(transparent, transparent 10px, rgba(0, 255, 0, 0.15) 10px, rgba(0, 255, 0, 0.15) 20px);
        animation: matrixBackground 60s linear infinite;
        pointer-events: none;
        z-index: -1;
    }
    .fullscreen-window {
        display: none; /* Initially hidden */
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.95);
        color: lime;
        padding: 20px;
        box-sizing: border-box;
        font-size: 16px;
        z-index: 10; /* Ensure it's above everything else */
        overflow: auto;
        animation: fadeIn 2s forwards; /* Use the existing fadeIn animation */
    }
</style>
</head>
<body>

<div id="matrix"></div>
<div id="fullscreen-window" class="fullscreen-window">
    <h2>Assembler Script Simulation</h2>
    <p>Simulating the compilation of the assembler script...</p>
    <pre id="assembler-output"></pre>
</div>
<div id="final-fullscreen-window" class="fullscreen-window" style="display: none;">
    <h2>Final Simulation Complete!</h2>
    <p>Generative AI Model Processed within 4.8 seconds</p>
</div>

<script>
function showSimulationCompleteWindow() {
    const windowDiv = document.createElement('div');
    windowDiv.className = 'window visible';
    windowDiv.style.textAlign = 'center'; // Center the text for emphasis
    windowDiv.innerHTML = `
        <h2>Autonomous Infrastructure is Ready!</h2>
        <p>All operations have finished executing.</p>
    `;

    // Ensures the final message is displayed after everything else
    document.getElementById('matrix').appendChild(windowDiv);
}

function simulateAssemblerScript() {
    // Extended and more complex assembler script simulation with hardware interactions
    const script = `
; Begin Kernel Operation Simulation
MOV AX, core_init
MOV BX, io_manager
CALL BX
MOV CX, mem_alloc
CALL CX
INT 20h

; Simulated Input/Output Operations
MOV DX, read_input
CALL DX
MOV EX, process_data
CALL EX
MOV FX, write_output
CALL FX

; Simulating hardware interactions
; Turning on lights
MOV AX, turn_on_lights
CALL AX

; Starting motor
MOV AX, start_motor
CALL AX

; Reading sensor data
MOV AX, read_sensors
CALL AX
MOV BX, AX ; Store sensor data in BX for processing

; Kernel Shutdown Procedure
MOV GX, shutdown_kernel
CALL GX
INT 20h
`;

    // Initially, show the script
    document.getElementById('assembler-output').textContent = script;

    // Simulate compilation and hardware interaction process
    setTimeout(() => {
        const compilationResult = `
; Script has compiled successfully!

; Status: 'Simulated Hardware Interactions'
Need Light Status: ON
Need Motor Status: RUNNING
Need Sensor Data: Acquired

; Simulated Linux Kernel Interaction
Input: "Hello, Kernel!"
Process: Data processing completed.
Output: "Processed: Hello, Kernel!"
Kernel Shutdown: Successful.
`;

        // Update the assembler output with the compilation and interaction results
        document.getElementById('assembler-output').textContent += compilationResult;

        // Visually simulate hardware interactions on the webpage
        simulateHardwareInteractions();

        // Call to show the final window, with a delay to ensure it's the last thing shown
        setTimeout(showSimulationCompleteWindow, 3000); // Show "Simulation Complete" after showing results
    }, 3000);
}

function simulateHardwareInteractions() {
    // Create elements to visually represent the hardware interactions
    const lightsIndicator = document.createElement('div');
    lightsIndicator.innerHTML = 'User Input: <span style="color:lime;">I need to have some lights turned on</span>';
    document.body.appendChild(lightsIndicator);

    const motorIndicator = document.createElement('div');
    motorIndicator.innerHTML = 'User Input: <span style="color:lime;">I need to have the motor running in the background</span>';
    document.body.appendChild(motorIndicator);

    const sensorIndicator = document.createElement('div');
    sensorIndicator.innerHTML = 'Contextual Interpretation:<span style="color:lime;"> Assembler interaction with Kernel for simulating lights and a motor runing in the background</span>';
    document.body.appendChild(sensorIndicator);

    // Additional visual effects for engagement
    document.body.style.backgroundColor = "white"; // Darken background to simulate "lights on"
    // Additional visual effects for engagement
    document.body.style.backgroundColor = "black"; // Darken background to simulate "lights on"
        const hardwareContainer = document.createElement('div');
    hardwareContainer.id = 'hardware-interactions';
    document.body.appendChild(hardwareContainer);

    // Light (LED) Status
    const ledStatus = document.createElement('p');
    ledStatus.innerHTML = 'LED on Pin 2: <strong>CONNECTED & ON</strong> (Digital HIGH)';
    hardwareContainer.appendChild(ledStatus);

    // Motor Status
    const motorStatus = document.createElement('p');
    motorStatus.innerHTML = 'Motor on Pins 3 (Direction) & 5 (Speed): <strong>CONNECTED & RUNNING</strong> (Direction: FORWARD, Speed: 50%)';
    hardwareContainer.appendChild(motorStatus);

    // Clock Speed Setting
    const clockSpeed = document.createElement('p');
    clockSpeed.innerHTML = 'Clock Speed: <strong>16MHz</strong>';
    hardwareContainer.appendChild(clockSpeed);

    // Sensor Data Acquired
    const sensorData = document.createElement('p');
    sensorData.innerHTML = 'Sensor Data: <strong>ACQUIRED</strong>';
    hardwareContainer.appendChild(sensorData);

}

// Assuming showSimulationCompleteWindow is defined elsewhere to handle final message display

// Call this function at the appropriate place in your script, possibly after creating server and data windows
simulateAssemblerScript();

const generateIPAddress = () => `192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;

const serverRoles = [
  {
    name: "Data Generation Server",
    process: "Generating data...",
    execute: () => {
      // Simulate generating data
      console.log("Generating random data...");
      const data = Array.from({ length: 10 }, () => Math.floor(Math.random() * 100));
      console.log("Generated data:", data);
      return data;
    }
  },
  {
    name: "Data Processing Server",
    process: "Processing data...",
    execute: (data) => {
      // Simulate processing data (e.g., sorting)
      console.log("Processing data...");
      const processedData = data.sort((a, b) => a - b);
      console.log("Processed data:", processedData);
      return processedData;
    }
  },
  {
    name: "Data Cleaning Server",
    process: "Cleaning data...",
    execute: (data) => {
      // Simulate cleaning data (e.g., removing duplicates)
      console.log("Cleaning data...");
      const cleanedData = [...new Set(data)];
      console.log("Cleaned data:", cleanedData);
      return cleanedData;
    }
  },
  {
    name: "Data Reiteration Server",
    process: "Reiterating data...",
    execute: (data) => {
      // Simulate reiterating over data (e.g., doubling values)
      console.log("Reiterating data...");
      const reiteratedData = data.map((item) => item * 2);
      console.log("Reiterated data:", reiteratedData);
      return reiteratedData;
    }
  },
  {
    name: "Data Output Server",
    process: "Outputting data...",
    execute: (data) => {
      // Simulate outputting data
      console.log("Outputting data:", data);
      // This could involve sending data to a file, database, or external system
    }
  }
];

// Example of running the simulated server roles in sequence
const data = serverRoles[0].execute();
const processedData = serverRoles[1].execute(data);
const cleanedData = serverRoles[2].execute(processedData);
const reiteratedData = serverRoles[3].execute(cleanedData);
serverRoles[4].execute(reiteratedData);

const windowData = [
    {
        title: 'Processor Load Calculation',
        content: () => `CPU Load at Time T: Load(T) = 1 - exp(-λ * T)<br>Where λ represents the arrival rate of tasks`
    },
    {
        title: 'Ohm\'s Law Variations for CPU Power',
        content: () => Array.from({length: 8}, () => `P = V^2 / R; Where V = ${Math.floor(Math.random() * 5) + 1}V, R = ${Math.floor(Math.random() * 100) + 1}Ω`).join('<br>')
    },
    {
        title: 'Capacitive Reactance in Clock Circuits',
        content: () => Array.from({length: 8}, () => `Xc = 1 / (2πfC); Where f = ${Math.floor(Math.random() * 1000) + 1}Hz, C = ${Math.floor(Math.random() * 100) + 1}μF`).join('<br>')
    },
    {
        title: 'Transistor Switching Times',
        content: () => Array.from({length: 8}, () => `t = RC; Where R = ${Math.floor(Math.random() * 1000) + 1}Ω, C = ${Math.floor(Math.random() * 100) + 1}pF`).join('<br>')
    },
    {
        title: 'Signal Integrity: Reflection Coefficient',
        content: () => Array.from({length: 8}, () => `Γ = (Zl - Zo) / (Zl + Zo); Where Zl = ${Math.floor(Math.random() * 100) + 50}Ω, Zo = 50Ω`).join('<br>')
    },
    {
        title: 'Kernel Context Switch Overhead',
        content: () => `Context Switch Time: t_cs = ${Math.floor(Math.random() * 20) + 5}μs<br>This time includes saving and loading process states`
    },
    {
        title: 'Fourier Transform for Signal Processing',
        content: () => `FT(f)(ω) = ∫ f(t) * e^(-2πiωt) dt<br>Used for converting time-domain signals to frequency-domain`
    },
    {
        title: 'Power Dissipation in CMOS Circuits',
        content: () => Array.from({length: 8}, () => `P = αCLV^2f; Where α = 0.5, CL = ${Math.floor(Math.random() * 10) + 1}fF, V = ${Math.floor(Math.random() * 2) + 1}V, f = ${Math.floor(Math.random() * 1000) + 500}MHz`).join('<br>')
    },
    {
        title: 'Nyquist Rate for ADC Conversion',
        content: () => Array.from({length: 8}, () => `f_nyquist = 2 * f_max; Where f_max = ${Math.floor(Math.random() * 1000) + 100}Hz`).join('<br>')
    },
    {
        title: 'Thermal Resistance in Heatsinks',
        content: () => Array.from({length: 8}, () => `Rθ = (T_j - T_a) / P; Where T_j = ${Math.floor(Math.random() * 150) + 100}°C, T_a = ${Math.floor(Math.random() * 25) + 25}°C, P = ${Math.floor(Math.random() * 100) + 10}W`).join('<br>')
    },

    {
        title: 'Power Dissipation Estimates',
        content: () => Array.from({length: 8}, () => `P = V^2 / R = ${Math.floor(Math.random() * 10 + 1)}W`).join('<br>')
    },
    {
        title: 'Filter Attenuation Levels',
        content: () => Array.from({length: 8}, () => `A = -20log(${Math.random().toFixed(2)}) dB`).join('<br>')
    },
    {
        title: 'Dynamic Data - Noise and Signal',
        content: () => Array.from({length: 8}, () => `Noise: ${Math.random().toFixed(2)} dB, Signal: ${Math.random().toFixed(2)}`).join('<br>')
    },
    {
        title: 'LLM Structured Data - Code Simulations',
        content: () => Array.from({length: 8}, () => `return ${Math.random().toFixed(2)}; // simulated output`).join('<br>')
    },
    {
        title: 'LLM Structured Data - Data Generation',
        content: () => Array.from({length: 8}, () => `[${Array.from({length: 3}, () => Math.random().toFixed(2)).join(', ')}],`).join('<br>')
    },
    {
        title: 'LLM Structured Data - Logic Constructs',
        content: () => Array.from({length: 8}, () => `if (input > ${Math.random().toFixed(2)}) { return true; } else { return false; }`).join('<br>')
    }
];

// Example function to dynamically create and update content boxes
function createAndUpdateBoxes() {
    windowData.forEach((data, index) => {
        const serverBox = document.getElementById(`server-box-${index}`);
        const dataDiv = document.createElement('div');
        dataDiv.innerHTML = `<h4>${data.title}</h4><p>${data.content()}</p>`;
        serverBox.appendChild(dataDiv);
    });
}

// Call this function to initialize the boxes after the document has loaded
document.addEventListener('DOMContentLoaded', createAndUpdateBoxes);
function createServerWindows() {
    serverRoles.forEach((server, index) => {
        setTimeout(() => {
            const ip = generateIPAddress(); // Dynamically generate IP address
            const windowDiv = document.createElement('div');
            windowDiv.className = 'window visible';
            windowDiv.innerHTML = `<h4>${server.name}</h4><div class="ip-address">${ip}</div><p>${server.process}</p>`;
            document.getElementById('matrix').insertBefore(windowDiv, document.getElementById('matrix').firstChild); // Insert at the start
        }, index * 1000); // Stagger the server windows appearance
    });
}

function createDataWindows() {
    windowData.forEach((data, index) => {
        setTimeout(() => {
            const windowDiv = document.createElement('div');
            windowDiv.className = 'window visible';
            windowDiv.innerHTML = `<h4>${data.title}</h4><p id="content-${index}" style="white-space: pre-line;">${data.content()}</p>`;
            document.getElementById('matrix').appendChild(windowDiv); // Append at the end
        }, (serverRoles.length * 500) + (index * 1000)); // Ensure data windows appear after server windows
    });
}

function showFinalSimulationCompleteWindow() {
    // This function displays the very last full-screen window with the final message
    const finalWindow = document.getElementById('final-fullscreen-window');
    finalWindow.style.display = 'block';
    finalWindow.style.zIndex = 20; // Ensure it covers everything else
}

function revealFinalSimulation() {
    const allWindows = document.querySelectorAll('.window');
    const lastWindowDelay = (allWindows.length * 500) + 5000 + 15000; // Consider the time for all windows plus assembler simulation and compilation result

    setTimeout(() => {
        document.getElementById('fullscreen-window').style.display = 'block';
        simulateAssemblerScript();

        // After the assembler script simulation, show the final simulation complete window
        setTimeout(showFinalSimulationCompleteWindow, 8000); // Adjust this time based on the length of your assembler simulation
    }, lastWindowDelay);
}

// Ensure server windows and data windows are created first
createServerWindows();
setTimeout(createDataWindows, serverRoles.length * 500);
revealFinalSimulation(); // Modified to include the final simulation complete window
// Set a timeout to redirect after showing the final results for 5 seconds
setTimeout(function() {
    window.location.href = "/"; // Redirect to the Flask route serving mainpage.html
}, 35000); // Adjust delay as per requirement

</script>


